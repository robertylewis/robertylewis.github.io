<html><head><title>category_theory.types</title><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><p></p>
</div><div class="entry"><a id="category_theory.types">      <h4>category_theory.types</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.large_category">category_theory.large_category</a> (Type u)</code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.types_hom">      <h4>category_theory.types_hom</h4><code>âˆ€ {Î± Î² : Type u}, (Î± âŸ¶ Î²) = (Î± â†’ Î²)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.types_id">      <h4>category_theory.types_id</h4><code>âˆ€ (X : Type u), ğŸ™ X = <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#id">id</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.types_comp">      <h4>category_theory.types_comp</h4><code>âˆ€ {X Y Z : Type u} (f : X âŸ¶ Y) (g : Y âŸ¶ Z), f â‰« g = g âˆ˜ f</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor.sections">      <h4>category_theory.functor.sections</h4><code>Î  {J : Type u} [ğ’¥ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> J] (F : J â¥¤ Type w), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/data/set.html#set">set</a> (Î  (j : J), F.obj j)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.functor_to_types.map_comp">      <h4>category_theory.functor_to_types.map_comp</h4><code>âˆ€ {C : Type u} [ğ’ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F : C â¥¤ Type w) {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z)
(a : F.obj X), F.map (f â‰« g) a = F.map g (F.map f a)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.map_id">      <h4>category_theory.functor_to_types.map_id</h4><code>âˆ€ {C : Type u} [ğ’ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F : C â¥¤ Type w) {X : C} (a : F.obj X), F.map (ğŸ™ X) a = a</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.naturality">      <h4>category_theory.functor_to_types.naturality</h4><code>âˆ€ {C : Type u} [ğ’ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G : C â¥¤ Type w) {X Y : C} (Ïƒ : F âŸ¶ G) (f : X âŸ¶ Y)
(x : F.obj X), Ïƒ.app Y (F.map f x) = G.map f (Ïƒ.app X x)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.functor_to_types.comp">      <h4>category_theory.functor_to_types.comp</h4><code>âˆ€ {C : Type u} [ğ’ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G H : C â¥¤ Type w) {X : C} (Ïƒ : F âŸ¶ G) (Ï„ : G âŸ¶ H)
(x : F.obj X), (Ïƒ â‰« Ï„).app X x = Ï„.app X (Ïƒ.app X x)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.functor_to_types.hcomp">      <h4>category_theory.functor_to_types.hcomp</h4><code>âˆ€ {C : Type u} [ğ’ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> C] (F G : C â¥¤ Type w) (Ïƒ : F âŸ¶ G) {D : Type u'}
[ğ’Ÿ : <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.category">category_theory.category</a> D] (I J : D â¥¤ C) (Ï : I âŸ¶ J) {W : D} (x : (I â‹™ F).obj W),
  (Ï â—« Ïƒ).app W x = G.map (Ï.app W) (Ïƒ.app (I.obj W) x)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.ulift_trivial">      <h4>category_theory.ulift_trivial</h4><code>Î  (V : Type u), <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> V â‰… V</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.ulift_functor">      <h4>category_theory.ulift_functor</h4><code>Type u â¥¤ Type (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/algebra/functions.html#max">max</a> u v)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.ulift_functor_map">      <h4>category_theory.ulift_functor_map</h4><code>âˆ€ {X Y : Type u} (f : X âŸ¶ Y) (x : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/logic.html#ulift">ulift</a> X), category_theory.ulift_functor.map f x = {down := f (x.down)}</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.ulift_functor_full">      <h4>category_theory.ulift_functor_full</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.ulift_functor_faithful">      <h4>category_theory.ulift_functor_faithful</h4><code><a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.ulift_functor">category_theory.ulift_functor</a></code>
<div class="indent"><p><p></p>
</p>       Attributes: instance</div>
</div><div class="entry"><a id="category_theory.hom_of_element">      <h4>category_theory.hom_of_element</h4><code>Î  {X : Type u}, X â†’ (<a href="/home/rob/lean/mathlib/scripts/html_out/core/init/core.html#punit">punit</a> âŸ¶ X)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.hom_of_element_eq_iff">      <h4>category_theory.hom_of_element_eq_iff</h4><code>âˆ€ {X : Type u} (x y : X), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> x = <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.hom_of_element">category_theory.hom_of_element</a> y â†” x = y</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.mono_iff_injective">      <h4>category_theory.mono_iff_injective</h4><code>âˆ€ {X Y : Type u} (f : X âŸ¶ Y), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.mono">category_theory.mono</a> f â†” <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.injective">function.injective</a> f</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.epi_iff_surjective">      <h4>category_theory.epi_iff_surjective</h4><code>âˆ€ {X Y : Type u} (f : X âŸ¶ Y), <a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/category/default.html#category_theory.epi">category_theory.epi</a> f â†” <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/function.html#function.surjective">function.surjective</a> f</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.of_type_functor">      <h4>category_theory.of_type_functor</h4><code>Î  (m : Type u â†’ Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m], Type u â¥¤ Type v</code>
<div class="indent"><p><p><code>of_type_functor m</code> converts from Lean's <code>Type</code>-based <code>category</code> to <code>category_theory</code>. This
allows us to use these functors in category theory.</p>
</p>       </div>
</div><div class="entry"><a id="category_theory.of_type_functor_obj">      <h4>category_theory.of_type_functor_obj</h4><code>âˆ€ (m : Type u â†’ Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m],
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).obj = m</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.of_type_functor_map">      <h4>category_theory.of_type_functor_map</h4><code>âˆ€ (m : Type u â†’ Type v) [_inst_1 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/functor.html#functor">functor</a> m] [_inst_2 : <a href="/home/rob/lean/mathlib/scripts/html_out/core/init/category/lawful.html#is_lawful_functor">is_lawful_functor</a> m] {Î± Î² : Type u} (f : Î± â†’ Î²),
  (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.of_type_functor">category_theory.of_type_functor</a> m).map f = functor.map f</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="equiv.to_iso">      <h4>equiv.to_iso</h4><code>Î  {X Y : Type u}, X â‰ƒ Y â†’ (X â‰… Y)</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="equiv.to_iso_hom">      <h4>equiv.to_iso_hom</h4><code>âˆ€ {X Y : Type u} {e : X â‰ƒ Y}, (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).hom = â‡‘e</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="equiv.to_iso_inv">      <h4>equiv.to_iso_inv</h4><code>âˆ€ {X Y : Type u} {e : X â‰ƒ Y}, (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#equiv.to_iso">equiv.to_iso</a> e).inv = â‡‘(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> e)</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.iso.to_equiv">      <h4>category_theory.iso.to_equiv</h4><code>Î  {X Y : Type u}, (X â‰… Y) â†’ X â‰ƒ Y</code>
<div class="indent"><p><p></p>
</p>       </div>
</div><div class="entry"><a id="category_theory.iso.to_equiv_fun">      <h4>category_theory.iso.to_equiv_fun</h4><code>âˆ€ {X Y : Type u} (i : X â‰… Y), â‡‘(<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i) = i.hom</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div><div class="entry"><a id="category_theory.iso.to_equiv_symm_fun">      <h4>category_theory.iso.to_equiv_symm_fun</h4><code>âˆ€ {X Y : Type u} (i : X â‰… Y), â‡‘(<a href="/home/rob/lean/mathlib/scripts/html_out/data/equiv/basic.html#equiv.symm">equiv.symm</a> (<a href="/home/rob/lean/mathlib/scripts/html_out/category_theory/types.html#category_theory.iso.to_equiv">category_theory.iso.to_equiv</a> i)) = i.inv</code>
<div class="indent"><p><p></p>
</p>       Attributes: simp</div>
</div></body></html>
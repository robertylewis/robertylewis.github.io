<!DOCTYPE html><html lang="en"><head><title>category_theory.equivalence</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="nav"><div class="title">mathlib API docs</div><a href="https://robertylewis.com/mathlib_docs/index.html">root</a>/<br><a href="https://robertylewis.com/mathlib_docs/category_theory/index.html">category_theory</a>/<br><a href="equivalence.html">equivalence</a></div><div class="mod_doc"><p></p>
</div><div class="cnst"><a id="category_theory.equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L24">category_theory.equivalence</a></span> <span class="decl_args">(C : Type uâ‚)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">(D : Type uâ‚‚)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> uâ‚ uâ‚‚ vâ‚ vâ‚‚)</div>
<div class="indent"><p>We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law <code>FÎ· â‰« ÎµF = 1</code>, or in other
 words the composite <code>F âŸ¶ FGF âŸ¶ F</code> is the identity.</p>

<p>The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like <code>F âŸ¶ F1</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.unit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L42">category_theory.equivalence.unit</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">ğŸ­ C âŸ¶ e.functor â‹™ e.inverse</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.counit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L43">category_theory.equivalence.counit</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">e.inverse â‹™ e.functor âŸ¶ ğŸ­ D</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.unit_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L44">category_theory.equivalence.unit_inv</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">e.functor â‹™ e.inverse âŸ¶ ğŸ­ C</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.counit_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L45">category_theory.equivalence.counit_inv</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">ğŸ­ D âŸ¶ e.inverse â‹™ e.functor</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.unit_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L47">category_theory.equivalence.unit_def</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.unit_iso).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L48">category_theory.equivalence.counit_def</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.counit_iso).hom = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inv_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L49">category_theory.equivalence.unit_inv_def</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.unit_iso).inv = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_inv_def"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L50">category_theory.equivalence.counit_inv_def</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.counit_iso).inv = <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.functor_unit_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L52">category_theory.equivalence.functor_unit_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X) â‰«
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app ((e.functor).obj X) =
  ğŸ™ ((e.functor).obj X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.counit_inv_functor_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L56">category_theory.equivalence.counit_inv_functor_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app ((e.functor).obj X) â‰«
    (e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X) =
  ğŸ™ ((e.functor).obj X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.functor_unit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L64">category_theory.equivalence.functor_unit</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app ((e.functor).obj X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.counit_functor"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L68">category_theory.equivalence.counit_functor</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app ((e.functor).obj X) =
  (e.functor).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inverse_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L74">category_theory.equivalence.unit_inverse_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app ((e.inverse).obj Y) â‰«
    (e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app Y) =
  ğŸ™ ((e.inverse).obj Y)</div>
<div class="indent"><p>The other triangle equality. The proof follows the following proof in Globular:
 http://globular.science/1905.001</p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inverse_counit_inv_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L95">category_theory.equivalence.inverse_counit_inv_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y) â‰«
    (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app ((e.inverse).obj Y) =
  ğŸ™ ((e.inverse).obj Y)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.unit_inverse"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L103">category_theory.equivalence.unit_inverse</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app ((e.inverse).obj Y) =
  (e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.inverse_counit"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L107">category_theory.equivalence.inverse_counit</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(Y : D)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app Y) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app ((e.inverse).obj Y)</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L111">category_theory.equivalence.fun_inv_map</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X Y : D)</span> <span class="decl_args">(f : X âŸ¶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.functor).map ((e.inverse).map f) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app X â‰« f â‰« (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L115">category_theory.equivalence.inv_fun_map</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X âŸ¶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(e.inverse).map ((e.functor).map f) =
  (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X â‰« f â‰« (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.adjointify_Î·"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L123">category_theory.equivalence.adjointify_Î·</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C â¥¤ D}</span> <span class="decl_args">{G : D â¥¤ C}</span> <span class="decl_args">(Î· : ğŸ­ C â‰… F â‹™ G)</span> <span class="decl_args">(Îµ : G â‹™ F â‰… ğŸ­ D)</span> <span class="decl_args">:</span>       <div class="decl_type">ğŸ­ C â‰… F â‹™ G</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.adjointify_Î·_Îµ"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L133">category_theory.equivalence.adjointify_Î·_Îµ</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C â¥¤ D}</span> <span class="decl_args">{G : D â¥¤ C}</span> <span class="decl_args">(Î· : ğŸ­ C â‰… F â‹™ G)</span> <span class="decl_args">(Îµ : G â‹™ F â‰… ğŸ­ D)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map (((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.adjointify_Î·">category_theory.equivalence.adjointify_Î·</a> Î· Îµ).hom).app X) â‰« (Îµ.hom).app (F.obj X) = ğŸ™ (F.obj X)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L146">category_theory.equivalence.mk</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">(G : D â¥¤ C)</span> <span class="decl_args">(Î· : ğŸ­ C â‰… F â‹™ G)</span> <span class="decl_args">(Îµ : G â‹™ F â‰… ğŸ­ D)</span> <span class="decl_args">:</span>       <div class="decl_type">C â‰Œ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.refl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L151">category_theory.equivalence.refl</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">C â‰Œ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.symm"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L154">category_theory.equivalence.symm</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type">D â‰Œ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.trans"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L160">category_theory.equivalence.trans</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(f : D â‰Œ E)</span> <span class="decl_args">:</span>       <div class="decl_type">C â‰Œ E</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.fun_inv_id_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L169">category_theory.equivalence.fun_inv_id_assoc</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : C â¥¤ E)</span> <span class="decl_args">:</span>       <div class="decl_type">e.functor â‹™ e.inverse â‹™ F â‰… F</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_id_assoc_hom_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L172">category_theory.equivalence.fun_inv_id_assoc_hom_app</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : C â¥¤ E)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.fun_inv_id_assoc">category_theory.equivalence.fun_inv_id_assoc</a> e F).hom).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit_inv">category_theory.equivalence.unit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.fun_inv_id_assoc_inv_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L176">category_theory.equivalence.fun_inv_id_assoc_inv_app</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : C â¥¤ E)</span> <span class="decl_args">(X : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.fun_inv_id_assoc">category_theory.equivalence.fun_inv_id_assoc</a> e F).inv).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.unit">category_theory.equivalence.unit</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.equivalence.inv_fun_id_assoc"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L180">category_theory.equivalence.inv_fun_id_assoc</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : D â¥¤ E)</span> <span class="decl_args">:</span>       <div class="decl_type">e.inverse â‹™ e.functor â‹™ F â‰… F</div>
<div class="indent"><p></p>
       </div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_id_assoc_hom_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L183">category_theory.equivalence.inv_fun_id_assoc_hom_app</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : D â¥¤ E)</span> <span class="decl_args">(X : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.inv_fun_id_assoc">category_theory.equivalence.inv_fun_id_assoc</a> e F).hom).app X = F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit">category_theory.equivalence.counit</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.equivalence.inv_fun_id_assoc_inv_app"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L187">category_theory.equivalence.inv_fun_id_assoc_inv_app</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(e : C â‰Œ D)</span> <span class="decl_args">(F : D â¥¤ E)</span> <span class="decl_args">(X : D)</span> <span class="decl_args">:</span>       <div class="decl_type">((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.inv_fun_id_assoc">category_theory.equivalence.inv_fun_id_assoc</a> e F).inv).app X =
  F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.counit_inv">category_theory.equivalence.counit_inv</a> e).app X)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="cnst"><a id="category_theory.is_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L195">category_theory.is_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> uâ‚ uâ‚‚ vâ‚ vâ‚‚)</div>
<div class="indent"><p>A functor that is part of a (half) adjoint equivalence</p>
       </div>
</div><div class="def"><a id="category_theory.is_equivalence.of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L207">category_theory.is_equivalence.of_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F.functor)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.is_equivalence.of_equivalence_inverse"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L210">category_theory.is_equivalence.of_equivalence_inverse</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â‰Œ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F.inverse)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.is_equivalence.mk"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L214">category_theory.is_equivalence.mk</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{F : C â¥¤ D}</span> <span class="decl_args">(G : D â¥¤ C)</span> <span class="decl_args">(Î· : ğŸ­ C â‰… F â‹™ G)</span> <span class="decl_args">(Îµ : G â‹™ F â‰… ğŸ­ D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.as_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L223">category_theory.functor.as_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">C â‰Œ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_refl"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L228">category_theory.functor.is_equivalence_refl</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (ğŸ­ C)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.functor.inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L232">category_theory.functor.inv</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">D â¥¤ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_inv"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L235">category_theory.functor.is_equivalence_inv</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.functor.fun_inv_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L238">category_theory.functor.fun_inv_id</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type">F â‹™ <a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F â‰… ğŸ­ C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.inv_fun_id"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L241">category_theory.functor.inv_fun_id</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F â‹™ F â‰… ğŸ­ D</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.is_equivalence_trans"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L247">category_theory.functor.is_equivalence_trans</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">{E : Type uâ‚ƒ}</span> <span class="decl_args">[â„° : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> E]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">(G : D â¥¤ E)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> G]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> (F â‹™ G)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="thm"><a id="category_theory.is_equivalence.fun_inv_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L255">category_theory.is_equivalence.fun_inv_map</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">(X Y : D)</span> <span class="decl_args">(f : X âŸ¶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">F.map ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F).map f) =
  ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv_fun_id">category_theory.functor.inv_fun_id</a> F).hom).app X â‰« f â‰« ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv_fun_id">category_theory.functor.inv_fun_id</a> F).inv).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.inv_fun_map"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L261">category_theory.is_equivalence.inv_fun_map</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">(X Y : C)</span> <span class="decl_args">(f : X âŸ¶ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.inv">category_theory.functor.inv</a> F).map (F.map f) =
  ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.fun_inv_id">category_theory.functor.fun_inv_id</a> F).hom).app X â‰« f â‰« ((<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.fun_inv_id">category_theory.functor.fun_inv_id</a> F).inv).app Y</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.functor_unit_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L270">category_theory.is_equivalence.functor_unit_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> E]</span> <span class="decl_args">(Y : C)</span> <span class="decl_args">:</span>       <div class="decl_type">E.map (((category_theory.is_equivalence.unit_iso E).hom).app Y) â‰«
    ((category_theory.is_equivalence.counit_iso E).hom).app (E.obj Y) =
  ğŸ™ (E.obj ((ğŸ­ C).obj Y))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.is_equivalence.counit_inv_functor_comp"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L274">category_theory.is_equivalence.counit_inv_functor_comp</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(E : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> E]</span> <span class="decl_args">(Y : C)</span> <span class="decl_args">:</span>       <div class="decl_type">((category_theory.is_equivalence.counit_iso E).inv).app (E.obj Y) â‰«
    E.map (((category_theory.is_equivalence.unit_iso E).inv).app Y) =
  ğŸ™ ((ğŸ­ D).obj (E.obj Y))</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="cnst"><a id="category_theory.ess_surj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L280">category_theory.ess_surj</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">:</span>       <div class="decl_type">Type (<a href="https://robertylewis.com/mathlib_docs/core/init/algebra/functions.html#max">max</a> uâ‚ uâ‚‚ vâ‚‚)</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.obj_preimage"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L287">category_theory.functor.obj_preimage</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">C</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.functor.fun_obj_preimage_iso"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L288">category_theory.functor.fun_obj_preimage_iso</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">(d : D)</span> <span class="decl_args">:</span>       <div class="decl_type">F.obj (<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.functor.obj_preimage">category_theory.functor.obj_preimage</a> F d) â‰… d</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.ess_surj_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L294">category_theory.equivalence.ess_surj_of_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F</div>
<div class="indent"><p></p>
       </div>
</div><div class="def"><a id="category_theory.equivalence.faithful_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L297">category_theory.equivalence.faithful_of_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> F</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.equivalence.full_of_equivalence"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L304">category_theory.equivalence.full_of_equivalence</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> F</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.equivalence.equivalence_of_fully_faithfully_ess_surj"></a>      <span class="decl_name"><a href="https://github.com/leanprover-community/mathlib/blob/ca216162e074846f63031bc89eb168703ec00ed7/src/category_theory/equivalence.lean#L330">category_theory.equivalence.equivalence_of_fully_faithfully_ess_surj</a></span> <span class="decl_args">{C : Type uâ‚}</span> <span class="decl_args">[ğ’ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> C]</span> <span class="decl_args">{D : Type uâ‚‚}</span> <span class="decl_args">[ğ’Ÿ : <a href="https://robertylewis.com/mathlib_docs/category_theory/category/default.html#category_theory.category">category_theory.category</a> D]</span> <span class="decl_args">(F : C â¥¤ D)</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.full">category_theory.full</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> F]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.ess_surj">category_theory.ess_surj</a> F]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/equivalence.html#category_theory.is_equivalence">category_theory.is_equivalence</a> F</div>
<div class="indent"><p></p>
       </div>
</div></body></html>
<!DOCTYPE html><html lang="en"><head><title>category_theory.concrete_category.basic</title><meta charset="UTF-8"><link rel="stylesheet" href="https://robertylewis.com/mathlib_docs/style.css"></head><body><div class="mod_doc"><h1>Concrete categories</h1>

<p>A concrete category is a category <code>C</code> with a fixed faithful functor
<code>forget : C ‚•§ Type*</code>.  We define concrete categories using <code>class
concrete_category</code>.  In particular, we impose no restrictions on the
carrier type <code>C</code>, so <code>Type</code> is a concrete category with the identity
forgetful functor.</p>

<p>Each concrete category <code>C</code> comes with a canonical faithful functor
<code>forget C : C ‚•§ Type*</code>.  We say that a concrete category <code>C</code> admits a
<em>forgetful functor</em> to a concrete category <code>D</code>, if it has a functor
<code>forget‚ÇÇ C D : C ‚•§ D</code> such that <code>(forget‚ÇÇ C D) ‚ãô (forget D) = forget
C</code>, see <code>class has_forget‚ÇÇ</code>.  Due to <code>faithful.div_comp</code>, it suffices
to verify that <code>forget‚ÇÇ.obj</code> and <code>forget‚ÇÇ.map</code> agree with the equality
above; then <code>forget‚ÇÇ</code> will satisfy the functor laws automatically, see
<code>has_forget‚ÇÇ.mk'</code>.</p>

<p>Two classes helping construct concrete categories in the two most
common cases are provided in the files <code>bundled_hom</code> and
<code>unbundled_hom</code>, see their documentation for details.</p>

<h2>References</h2>

<p>See [Ahrens and Lumsdaine, <em>Displayed Categories</em>][ahrens2017] for
related work.</p>
</div><div class="cnst"><a id="category_theory.concrete_category"></a>      <span class="decl_name">category_theory.concrete_category</span> <span class="decl_args">(C : Type (u+1))</span> <span class="decl_args">:</span>       <div class="decl_type">Type (u+1)</div>
<div class="indent"><p>A concrete category is a category <code>C</code> with a fixed faithful functor <code>forget : C ‚•§ Type</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.forget"></a>      <span class="decl_name">category_theory.forget</span> <span class="decl_args">(C : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type">C ‚•§ Type u</div>
<div class="indent"><p>The forgetful functor from a concrete category to <code>Type u</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.concrete_category.has_coe_to_sort"></a>      <span class="decl_name">category_theory.concrete_category.has_coe_to_sort</span> <span class="decl_args">(C : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#has_coe_to_sort">has_coe_to_sort</a> C</div>
<div class="indent"><p>Provide a coercion to <code>Type u</code> for a concrete category. This is not marked as an instance
as it could potentially apply to every type, and so is too expensive in typeclass search.</p>

<p>You can use it on particular examples as:
<code>lean
instance : has_coe_to_sort X := concrete_category.has_coe_to_sort X
</code></p>
       </div>
</div><div class="thm"><a id="category_theory.forget_obj_eq_coe"></a>      <span class="decl_name">category_theory.forget_obj_eq_coe</span> <span class="decl_args">{C : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> C).obj X = ‚Ü•X</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.concrete_category.has_coe_to_fun"></a>      <span class="decl_name">category_theory.concrete_category.has_coe_to_fun</span> <span class="decl_args">{C : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/core/init/coe.html#has_coe_to_fun">has_coe_to_fun</a> (X ‚ü∂ Y)</div>
<div class="indent"><p>Usually a bundled hom structure already has a coercion to function
that works with different universes. So we don't use this as a global instance.</p>
       </div>
</div><div class="thm"><a id="category_theory.forget_map_eq_coe"></a>      <span class="decl_name">category_theory.forget_map_eq_coe</span> <span class="decl_args">{C : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">{X Y : C}</span> <span class="decl_args">(f : X ‚ü∂ Y)</span> <span class="decl_args">:</span>       <div class="decl_type">(<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> C).map f = ‚áëf</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.coe_id"></a>      <span class="decl_name">category_theory.coe_id</span> <span class="decl_args">{C : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">{X : C}</span> <span class="decl_args">(x : ‚Ü•X)</span> <span class="decl_args">:</span>       <div class="decl_type">‚áë(ùüô X) x = x</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="thm"><a id="category_theory.coe_comp"></a>      <span class="decl_name">category_theory.coe_comp</span> <span class="decl_args">{C : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">{X Y Z : C}</span> <span class="decl_args">(f : X ‚ü∂ Y)</span> <span class="decl_args">(g : Y ‚ü∂ Z)</span> <span class="decl_args">(x : ‚Ü•X)</span> <span class="decl_args">:</span>       <div class="decl_type">‚áë(f ‚â´ g) x = ‚áëg (‚áëf x)</div>
<div class="indent"><p></p>
       Attributes: simp</div>
</div><div class="def"><a id="category_theory.concrete_category.types"></a>      <span class="decl_name">category_theory.concrete_category.types</span>  <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> (Type u)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="cnst"><a id="category_theory.has_forget‚ÇÇ"></a>      <span class="decl_name">category_theory.has_forget‚ÇÇ</span> <span class="decl_args">(C D : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">:</span>       <div class="decl_type">Type (u+1)</div>
<div class="indent"><p><code>has_forget‚ÇÇ C D</code>, where <code>C</code> and <code>D</code> are both concrete categories, provides a functor
<code>forget‚ÇÇ C D : C ‚•§ C</code> and a proof that <code>forget‚ÇÇ ‚ãô (forget D) = forget C</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.forget‚ÇÇ"></a>      <span class="decl_name">category_theory.forget‚ÇÇ</span> <span class="decl_args">(C D : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.has_forget‚ÇÇ">category_theory.has_forget‚ÇÇ</a> C D]</span> <span class="decl_args">:</span>       <div class="decl_type">C ‚•§ D</div>
<div class="indent"><p>The forgetful functor <code>C ‚•§ D</code> between concrete categories for which we have an instance
<code>has_forget‚ÇÇ C</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.forget_faithful"></a>      <span class="decl_name">category_theory.forget_faithful</span> <span class="decl_args">(C D : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.has_forget‚ÇÇ">category_theory.has_forget‚ÇÇ</a> C D]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/fully_faithful.html#category_theory.faithful">category_theory.faithful</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget‚ÇÇ">category_theory.forget‚ÇÇ</a> C D)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.induced_category.concrete_category"></a>      <span class="decl_name">category_theory.induced_category.concrete_category</span> <span class="decl_args">{C D : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">(f : C ‚Üí D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/full_subcategory.html#category_theory.induced_category">category_theory.induced_category</a> D f)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.induced_category.has_forget‚ÇÇ"></a>      <span class="decl_name">category_theory.induced_category.has_forget‚ÇÇ</span> <span class="decl_args">{C D : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">(f : C ‚Üí D)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.has_forget‚ÇÇ">category_theory.has_forget‚ÇÇ</a> (<a href="https://robertylewis.com/mathlib_docs/category_theory/full_subcategory.html#category_theory.induced_category">category_theory.induced_category</a> D f) D</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div><div class="def"><a id="category_theory.has_forget‚ÇÇ.mk'"></a>      <span class="decl_name">category_theory.has_forget‚ÇÇ.mk'</span> <span class="decl_args">{C D : Type (u+1)}</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> D]</span> <span class="decl_args">(obj : C ‚Üí D)</span> <span class="decl_args">(h_obj : ‚àÄ (X : C), (<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> D).obj (obj X) = (<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> C).obj X)</span> <span class="decl_args">(map : Œ† {X Y : C}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y))</span> <span class="decl_args">(h_map : ‚àÄ {X Y : C} {f : X ‚ü∂ Y}, (<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> D).map (map f) == (<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.forget">category_theory.forget</a> C).map f)</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.has_forget‚ÇÇ">category_theory.has_forget‚ÇÇ</a> C D</div>
<div class="indent"><p>In order to construct a ‚Äúpartially forgetting‚Äù functor, we do not need to verify functor laws;
it suffices to ensure that compositions agree with <code>forget‚ÇÇ C D ‚ãô forget D = forget C</code>.</p>
       </div>
</div><div class="def"><a id="category_theory.has_forget_to_Type"></a>      <span class="decl_name">category_theory.has_forget_to_Type</span> <span class="decl_args">(C : Type (u+1))</span> <span class="decl_args">[<a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.concrete_category">category_theory.concrete_category</a> C]</span> <span class="decl_args">:</span>       <div class="decl_type"><a href="https://robertylewis.com/mathlib_docs/category_theory/concrete_category/basic.html#category_theory.has_forget‚ÇÇ">category_theory.has_forget‚ÇÇ</a> C (Type u)</div>
<div class="indent"><p></p>
       Attributes: instance</div>
</div></body></html>